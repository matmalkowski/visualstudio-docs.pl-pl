---
title: C6211 | Dokumentacja firmy Microsoft
ms.custom: ''
ms.date: 2018-06-30
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-devops-test
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- C6211
helpviewer_keywords:
- C6211
ms.assetid: 9b68243b-534c-4a05-b789-bb155dfcba1e
caps.latest.revision: 26
author: corob-msft
ms.author: gewarren
manager: ghogen
ms.openlocfilehash: d47cb3e1a51d17628a8088633568e3669c1d2c64
ms.sourcegitcommit: 55f7ce2d5d2e458e35c45787f1935b237ee5c9f8
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/22/2018
ms.locfileid: "42696768"
---
# <a name="c6211"></a>C6211
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Najnowszą wersję tego tematu znajduje się w temacie [C6211](https://docs.microsoft.com/visualstudio/code-quality/c6211).  
  
Ostrzeżenie C6211: przecieki pamięci \<wskaźnik > z powodu wyjątku. Należy wziąć pod uwagę przy użyciu lokalnego bloku catch do wyczyszczenia pamięci  
  
 To ostrzeżenie wskazuje, że że przydzielonej pamięci jest nie zwalniane gdy wyjątek jest zgłaszany. Wykonywanie instrukcji na końcu ścieżki może zgłosić wyjątek. Analizator sprawdza ten dodatkowy warunek tylko wtedy, gdy `_Analysis_mode_(_Analysis_local_leak_checks_)` sal jest określony. Domyślnie ta adnotacja jest określona dla kodu (sterownika) trybu jądra Windows. Aby uzyskać więcej informacji na temat adnotacji SAL, zobacz [przy użyciu adnotacji SAL w celu zmniejszenia defektów kodu C/C++](../code-quality/using-sal-annotations-to-reduce-c-cpp-code-defects.md).  
  
## <a name="example"></a>Przykład  
 Poniższy kod generuje, to ostrzeżenie, ponieważ może się wyjątek podczas drugiego alokacji, a tym samym przeciek pierwszy alokacji lub może zostać zgłoszony wyjątek gdzieś w kodzie, który jest reprezentowany przez "`code ...`" komentarz i tym samym przecieki pamięci zarówno alokacji.  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4   
#include <sal.h>  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
void f( )  
{  
    char *p1 = new char[10];  
    char *p2 = new char[10];  
  
    // code ...  
  
    delete[] p2;  
    delete[] p1;  
}  
  
```  
  
 Aby użyć tej samej metody alokacji i rozwiązać ten problem, Dodaj program obsługi wyjątku:  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4  
#include <sal.h>  
#include <new>  
#include <iostream>  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
void f()  
{  
    char *p1 = nullptr;   
    char *p2 = nullptr;  
  
    try  
    {  
        p1 = new char[10];  
        p2 = new char[10];  
  
        // code ...  
  
        delete [] p2;  
        delete [] p1;  
    }  
    catch (const bad_alloc& ba)  
    {  
        cout << ba.what() << endl;  
        delete [] p2;  
        delete [] p1;  
    }  
    // code ...  
}  
  
```  
  
 Aby całkowicie uniknąć tego rodzaju potencjalnymi wyciekami, użyj mechanizmów, które są dostarczane przez C++ standardowy szablon biblioteki (STL). Obejmują one [shared_ptr](http://msdn.microsoft.com/library/1469fc51-c658-43f1-886c-f4530dd84860), [unique_ptr](http://msdn.microsoft.com/library/acdf046b-831e-4a4a-83aa-6d4ee467db9a), i [wektor](http://msdn.microsoft.com/library/c1431ad8-c0b6-4dbb-89c4-5f651e432d7f). Aby uzyskać więcej informacji, zobacz [inteligentne wskaźniki](http://msdn.microsoft.com/library/909ef870-904c-49b6-b8cd-e9d0b7dc9435) i [standardowej biblioteki języka C++](http://msdn.microsoft.com/library/a37d3ba3-58af-47c7-9ee2-441ccd7b77ee).  
  
```cpp  
// cl.exe /analyze /c /EHsc /nologo /W4  
#include <sal.h>  
#include <vector>  
#include <memory>  
  
using namespace std;  
  
_Analysis_mode_(_Analysis_local_leak_checks_)   
  
void f( )  
{  
    // use 10-element vectors in place of char[10]  
    vector<char> v1;  
    vector<char> v2;  
  
    for (int i=0; i<10; ++i) {  
        v1.push_back('a');  
        v2.push_back('b');  
    }  
    // code ...  
  
    // use unique_ptr if you still want char[10]  
    unique_ptr<char[]> a1(new char[10]);  
    unique_ptr<char[]> a2(new char[10]);  
  
    // code ...  
  
    // No need for delete; vector and unique_ptr   
    // clean up when out of scope.  
}  
  
```  
  
## <a name="see-also"></a>Zobacz też  
 [Obsługa wyjątków języka C++](http://msdn.microsoft.com/library/65f80b44-9d0f-4d17-b910-07205a5c5c40)



